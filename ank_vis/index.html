<!DOCTYPE html>
<html>
  <head>
    <script type="text/javascript" src="d3.v2.min.js"></script>
    <script type="text/javascript" src="jquery-1.7.2.min.js"></script>

    <style type="text/css">
      circle {
        fill: steelblue;
      }

      .chart div {
        font: 10px sans-serif;
        background-color: steelblue;
        text-align: right;
        padding: 3px;
        margin: 1px;
        color: white;
      }
    </style>

  </head>
  <body>

    <div>Select overlay: <select id = "interpolate"></select></div>

    <div>
      <script type="text/javascript">

        var jsondata;

        var overlay_id = "phy"

        //TODO: strip out the polling, use websocket to push out changes

        function doPoll(){
          $.get('/overlay?id=' + overlay_id, function(data) {
              var data = jQuery.parseJSON(data);
              jsondata = data;
              redraw();
              setTimeout(doPoll, 5000);
              });
        }

doPoll(); //start the polling 

var nodes_by_id = {};

var pathinfo = [];

var socket_url = "ws://" + location.host + "/ws";
var ws = new WebSocket(socket_url);
ws.onopen = function() {
  ws.send("Hello, world");
  status_label.text("WebSocket connected");
};

ws.onmessage = function (evt) {
  //console.log(evt.data);
  var data = jQuery.parseJSON(evt.data);
  //console.log(data);
  //TODO: parse to see if valid traceroute path or other data
  pathinfo.push(data);
  console.log(data);
  //status_label.text(data);
  redraw_paths();
}
</script>

<script type="text/javascript">

  var chart = d3.select("body").append("svg")
  .attr("class", "chart")
  .attr("width", 1024)
  .attr("height", 800);

  var status_label = chart.append("text")
  .attr("class", "status label")
  .attr("y", 500)
  .attr("x", 0)
  .attr("font-family", "helvetica") 
  .attr("font-size", "14") 
  .text("")
  ;

  var clear_label = function() {
    status_label.text("");
  }

var trace_paths = chart.append("svg:g")
.attr("id", "path");

var nodes = d3.map;

var icon = function(d) {
  var filename = "icons/" + d.device_type;
  if (d.device_subtype != null && d.device_subtype != "None") {
    filename += "_" + d.device_subtype;

  }
  filename += ".svg";
  return filename;
}

var source_x = function(d) {
  return nodes[d.source].x + x_offset + 32;
}
var source_y = function(d) {
  return nodes[d.source].y  + y_offset+ 32;
}

var target_x = function(d) {
  return nodes[d.target].x + x_offset + 32;
}
var target_y = function(d) {
  return nodes[d.target].y  + y_offset+ 32;
}

var label = function(d) {
  return d.id;
}

var asn = function(d) {
  return d.asn;
}

var link_type = function(d) {
  return d.type;
}

var edge_id = function(d) {
  return d.edge_id;
}

d3.select("select").on("change", function() {
    console.log(this.value);
    });

var dropdown = d3.select("#interpolate")
.on("change", function() {
    overlay_id = this.value;
    jQuery.get('/overlay?id=' + overlay_id, function(data) {
      var data = jQuery.parseJSON(data);
      jsondata = data;
      redraw();
      });
    })


d3.json("/overlay?id=*", function(json) {
    dropdown
    .selectAll("option")
    .data(json)
    .enter().append("option")
    .attr("value", String)
    .text(String);
    });


// based on http://bl.ocks.org/2920551
var fill = d3.scale.category10();
var groupFill = function(d, i) { return fill(i); };
var groupPath = function(d) {
  return "M" + 
    d3.geom.hull(d.values.map(function(i) { return [i.x + x_offset + 32, i.y + y_offset + 32]; }))
    .join("L")
    + "Z";
}

var x_offset = 10;
var y_offset = 30;

var path_x = function(d) {
  node = nodes_by_id[d];
  //return nodes[index].x + 32;
  return node.x+ 32 + x_offset;
}

var path_y = function(d) {
  node = nodes_by_id[d];
  //return nodes[index].y+ 32;
  return node.y+ 32 + y_offset;
}

var node_info = function(d) {
  status_label.text("Node: " + d.label);
}

var group_info = function(d) {
  status_label.text("Group: " + d.key);
}

var link_info = function(d) {
  source = nodes[d.source];
  target = nodes[d.target];
  status_label.text("Link: " + source.label + " - " + target.label);
}

var status_label = chart.append("text")
    .attr("class", "status label")
    .attr("y", 15)
    .attr("x", 0)
    //.attr("font-family", "helvetica") 
    .attr("font-size", "16") 
    .text("test")
    ;

var node_attr_groups;
var edge_attr_groups;

//d3.json(
//'json/overlay/ip',
//function (jsondata) {
function redraw() {
  // create the chart here with
  // the returned data

  nodes = jsondata.nodes;
  //TODO: only update if changed
  nodes.forEach(function(node) {
      //todo: should this just be the index mapping?
      nodes_by_id[node.id] = node;
      });

  node_attr_groups = d3.nest().key(asn).entries(nodes);
  edge_attr_groups = d3.nest().key(function(d) { return d.type; }).entries(jsondata.links);

//TODO: make group path change/exit with node data
  groupings = chart.selectAll("path")
    .data(node_attr_groups)
    .attr("d", groupPath);

    groupings.enter().insert("path")
    .attr("d", groupPath)
    .style("fill", groupFill)
    .style("stroke", groupFill)
    .style("stroke-width", 80)
    .style("stroke-linejoin", "round")
    .style("opacity", 0.1)
      .on("mouseover", function(d){
          group_info(d);
        })
      .on("mouseout", function(){
      clear_label();
      });
    ;

    groupings.exit().transition()
    .duration(1000)
    .style("opacity",0)
    .remove();

  //TODO: filter the json data x and y ranges: store in nodes, and use this for the image plotting

  var line = chart.selectAll("line")
    //.data(jsondata.links, edge_id)
    .data(jsondata.links)

    //TODO: see why edge_id changes sometimes even though appears the same

    line.enter().append("line")
    .style("stroke", "rgb(6,120,155)")
    .on("mouseover", function(d){
        d3.select(this).style("stroke", "orange");
        d3.select(this).style("stroke-width", "4");
        link_info(d);
        })
  .on("mouseout", function(){
      d3.select(this).style("stroke-width", "1");
      d3.select(this).style("stroke", "rgb(6,120,155)");
      clear_label();
      });

  line 
    .attr("x1", source_x)
    .attr("y1", source_y)
    .attr("x2", target_x)
    .attr("y2", target_y)

    line.exit().transition()
    .duration(1000)
    .style("opacity",0)
    .remove();

  var node_id = function(d) {
    return d.label + d.network;
  }

  var image = chart.selectAll("image")
    .data(nodes, node_id);

  image.enter().append("image")
    .attr("x", function(d) { return d.x + x_offset; })
    .attr("y", function(d) { return d.y + y_offset; })
    .attr("width", 64)
    .attr("height", 64)
    .attr("xlink:href", icon)
    ;

  image
    .attr("x", function(d) { return d.x + x_offset; })
    .attr("y", function(d) { return d.y + y_offset; })
    .on("mouseover", function(d){
        node_info(d);
        })
  .on("mouseout", function(){
      clear_label();
      });

  image.exit().transition()
    .duration(1000)
    .style("opacity",0)
    .remove();

  device_labels = chart.selectAll(".device_label")
    .data(nodes)

    device_labels.enter().append("text")
    .attr("class", "device_label")
    .attr("text-anchor", "middle") 
    .attr("font-family", "helvetica") 
    .attr("font-size", "small") 

    //TODO: use a general accessor for x/y of nodes
    device_labels 
    .attr("x", function(d) { return d.x + x_offset; })
    .attr("y", function(d) { return d.y + y_offset; } )
    .attr("dx", 32) // padding-right
    .attr("dy", 65) // vertical-align: middle
    .text(function (d) { return d.id; } );

  device_labels.exit().transition()
    .duration(1000)
    .style("opacity",0)
    .remove();
  //});

    }

function redraw_paths() {

  var traceroute_line = d3.svg.line()
    .x(path_x)
    .y(path_y)
    .interpolate("cardinal")
    .tension(0.8)
    ;

  path2 = chart.selectAll("path")
    .data(pathinfo)

    path2.enter().append("path")
    .attr("d", traceroute_line)
    .style("stroke-width", 6)
    .style("stroke", "orange")
    .style("fill", "none")
    .on("mouseover", function(d){
        d3.select(this).style("stroke", "orange");
        d3.select(this).style("stroke-width", "5");
        //TODO: fix status label being selected with device labels
        //status_label.text(d);
        })
  .on("mouseout", function(){
      d3.select(this).style("stroke-width", "1");
      d3.select(this).style("stroke", "green");
      clear_label();
      })
  .transition()
    .duration(2000)
    .style("stroke-width", 2)
    .style("stroke", "green")
    .style("opacity",100)
    ;


}


function drawEdges() {

}

//TODO: set hover to display properties

</script>

    </div>
  </body>
</html>
